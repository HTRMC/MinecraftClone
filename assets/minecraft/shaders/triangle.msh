#version 450
#extension GL_EXT_mesh_shader : require

layout(binding = 0) uniform UniformBufferObject {
    mat4 model;
    mat4 view;
    mat4 proj;
} ubo;

// Block data storage buffer
layout(binding = 2) readonly buffer BlockData {
    uint blockTypes[];
};

// Chunk dimensions
const uint CHUNK_SIZE = 16;
const uint BLOCKS_PER_CHUNK = CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE; // 4096

// Max vertices and primitives per mesh shader invocation
// Each block has 24 vertices and 12 triangles
const uint MAX_BLOCKS_PER_INVOCATION = 10; // 240 vertices, 120 triangles (within limits)
const uint MAX_VERTICES = MAX_BLOCKS_PER_INVOCATION * 24;
const uint MAX_PRIMITIVES = MAX_BLOCKS_PER_INVOCATION * 12;

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = 240, max_primitives = 120) out;

layout(location = 0) out vec3 fragColor[];
layout(location = 1) out vec2 fragTexCoord[];
layout(location = 2) out flat uint fragBlockType[];

// Face vertex offsets for a unit cube
const vec3 cubeVertices[24] = vec3[24](
    // Front face (+Z)
    vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 1.0), vec3(1.0, 1.0, 1.0), vec3(0.0, 1.0, 1.0),
    // Back face (-Z)
    vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(1.0, 1.0, 0.0),
    // Top face (+Y)
    vec3(0.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 0.0), vec3(0.0, 1.0, 0.0),
    // Bottom face (-Y)
    vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(1.0, 0.0, 1.0), vec3(0.0, 0.0, 1.0),
    // Right face (+X)
    vec3(1.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0), vec3(1.0, 1.0, 1.0),
    // Left face (-X)
    vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 1.0), vec3(0.0, 1.0, 0.0)
);

const vec3 faceColors[6] = vec3[6](
    vec3(1.0, 0.0, 0.0), // Front - Red
    vec3(0.0, 1.0, 0.0), // Back - Green
    vec3(0.0, 0.0, 1.0), // Top - Blue
    vec3(1.0, 1.0, 0.0), // Bottom - Yellow
    vec3(1.0, 0.0, 1.0), // Right - Magenta
    vec3(0.0, 1.0, 1.0)  // Left - Cyan
);

const vec2 faceTexCoords[4] = vec2[4](
    vec2(0.0, 0.0), vec2(1.0, 0.0), vec2(1.0, 1.0), vec2(0.0, 1.0)
);

const uint faceIndices[36] = uint[36](
    0, 1, 2, 2, 3, 0,       // Front
    4, 5, 6, 6, 7, 4,       // Back
    8, 9, 10, 10, 11, 8,    // Top
    12, 13, 14, 14, 15, 12, // Bottom
    16, 17, 18, 18, 19, 16, // Right
    20, 21, 22, 22, 23, 20  // Left
);

void main() {
    uint workGroupID = gl_WorkGroupID.x;
    uint startBlock = workGroupID * MAX_BLOCKS_PER_INVOCATION;
    uint endBlock = min(startBlock + MAX_BLOCKS_PER_INVOCATION, BLOCKS_PER_CHUNK);

    // Count non-air blocks first
    uint solidBlockCount = 0;
    for (uint i = startBlock; i < endBlock; ++i) {
        if (blockTypes[i] != 0) { // 0 = AIR
            solidBlockCount++;
        }
    }

    uint numVertices = solidBlockCount * 24;
    uint numPrimitives = solidBlockCount * 12;

    SetMeshOutputsEXT(numVertices, numPrimitives);

    uint outputBlockIdx = 0;
    for (uint i = startBlock; i < endBlock; ++i) {
        uint blockType = blockTypes[i];

        // Skip air blocks
        if (blockType == 0) {
            continue;
        }

        // Calculate block position in chunk (x, y, z)
        // Index layout: y * CHUNK_SIZE * CHUNK_SIZE + z * CHUNK_SIZE + x
        uint x = i % CHUNK_SIZE;
        uint z = (i / CHUNK_SIZE) % CHUNK_SIZE;
        uint y = i / (CHUNK_SIZE * CHUNK_SIZE);

        vec3 blockPos = vec3(float(x), float(y), float(z));

        // Color based on block type for debugging
        vec3 blockColor;
        if (blockType == 1) blockColor = vec3(0.55, 0.27, 0.07); // DIRT - brown
        else if (blockType == 2) blockColor = vec3(0.3, 0.8, 0.3); // GRASS - green
        else if (blockType == 3) blockColor = vec3(0.5, 0.5, 0.5); // STONE - gray
        else if (blockType == 4) blockColor = vec3(0.6, 0.4, 0.2); // WOOD - brown
        else if (blockType == 5) blockColor = vec3(0.2, 0.6, 0.2); // LEAVES - dark green
        else if (blockType == 6) blockColor = vec3(0.9, 0.9, 0.6); // SAND - yellow
        else if (blockType == 7) blockColor = vec3(0.2, 0.4, 0.8); // WATER - blue
        else blockColor = vec3(1.0, 0.0, 1.0); // Unknown - magenta

        // Generate vertices for this block
        for (uint v = 0; v < 24; ++v) {
            uint vertexIdx = outputBlockIdx * 24 + v;
            vec3 worldPos = blockPos + cubeVertices[v];

            gl_MeshVerticesEXT[vertexIdx].gl_Position = ubo.proj * ubo.view * ubo.model * vec4(worldPos, 1.0);

            uint faceIdx = v / 4;
            // Mix block color with face color for better visibility
            fragColor[vertexIdx] = blockColor * 0.7 + faceColors[faceIdx] * 0.3;
            fragTexCoord[vertexIdx] = faceTexCoords[v % 4];
            fragBlockType[vertexIdx] = blockType;
        }

        // Generate triangle indices for this block
        for (uint t = 0; t < 12; ++t) {
            uint primIdx = outputBlockIdx * 12 + t;
            uint baseVertex = outputBlockIdx * 24;
            gl_PrimitiveTriangleIndicesEXT[primIdx] = uvec3(
                baseVertex + faceIndices[t * 3 + 0],
                baseVertex + faceIndices[t * 3 + 1],
                baseVertex + faceIndices[t * 3 + 2]
            );
        }

        outputBlockIdx++;
    }
}