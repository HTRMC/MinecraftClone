#version 450
#extension GL_EXT_mesh_shader : require

layout(binding = 0) uniform UniformBufferObject {
    mat4 model;
    mat4 view;
    mat4 proj;
} ubo;

// Chunk dimensions
const uint CHUNK_SIZE = 16;
const uint BLOCKS_PER_CHUNK = CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE; // 4096

// Max vertices and primitives per mesh shader invocation
// Each block has 24 vertices and 12 triangles
const uint MAX_BLOCKS_PER_INVOCATION = 10; // 240 vertices, 120 triangles (within limits)
const uint MAX_VERTICES = MAX_BLOCKS_PER_INVOCATION * 24;
const uint MAX_PRIMITIVES = MAX_BLOCKS_PER_INVOCATION * 12;

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = 240, max_primitives = 120) out;

layout(location = 0) out vec3 fragColor[];
layout(location = 1) out vec2 fragTexCoord[];

// Face vertex offsets for a unit cube
const vec3 cubeVertices[24] = vec3[24](
    // Front face (+Z)
    vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 1.0), vec3(1.0, 1.0, 1.0), vec3(0.0, 1.0, 1.0),
    // Back face (-Z)
    vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(1.0, 1.0, 0.0),
    // Top face (+Y)
    vec3(0.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 0.0), vec3(0.0, 1.0, 0.0),
    // Bottom face (-Y)
    vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(1.0, 0.0, 1.0), vec3(0.0, 0.0, 1.0),
    // Right face (+X)
    vec3(1.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0), vec3(1.0, 1.0, 1.0),
    // Left face (-X)
    vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 1.0), vec3(0.0, 1.0, 0.0)
);

const vec3 faceColors[6] = vec3[6](
    vec3(1.0, 0.0, 0.0), // Front - Red
    vec3(0.0, 1.0, 0.0), // Back - Green
    vec3(0.0, 0.0, 1.0), // Top - Blue
    vec3(1.0, 1.0, 0.0), // Bottom - Yellow
    vec3(1.0, 0.0, 1.0), // Right - Magenta
    vec3(0.0, 1.0, 1.0)  // Left - Cyan
);

const vec2 faceTexCoords[4] = vec2[4](
    vec2(0.0, 0.0), vec2(1.0, 0.0), vec2(1.0, 1.0), vec2(0.0, 1.0)
);

const uint faceIndices[36] = uint[36](
    0, 1, 2, 2, 3, 0,       // Front
    4, 5, 6, 6, 7, 4,       // Back
    8, 9, 10, 10, 11, 8,    // Top
    12, 13, 14, 14, 15, 12, // Bottom
    16, 17, 18, 18, 19, 16, // Right
    20, 21, 22, 22, 23, 20  // Left
);

void main() {
    uint workGroupID = gl_WorkGroupID.x;
    uint startBlock = workGroupID * MAX_BLOCKS_PER_INVOCATION;
    uint endBlock = min(startBlock + MAX_BLOCKS_PER_INVOCATION, BLOCKS_PER_CHUNK);
    uint numBlocks = endBlock - startBlock;

    uint numVertices = numBlocks * 24;
    uint numPrimitives = numBlocks * 12;

    SetMeshOutputsEXT(numVertices, numPrimitives);

    for (uint blockIdx = 0; blockIdx < numBlocks; ++blockIdx) {
        uint globalBlockIdx = startBlock + blockIdx;

        // Calculate block position in chunk (x, y, z)
        uint x = globalBlockIdx % CHUNK_SIZE;
        uint y = (globalBlockIdx / CHUNK_SIZE) % CHUNK_SIZE;
        uint z = globalBlockIdx / (CHUNK_SIZE * CHUNK_SIZE);

        vec3 blockPos = vec3(float(x), float(y), float(z));

        // Generate vertices for this block
        for (uint v = 0; v < 24; ++v) {
            uint vertexIdx = blockIdx * 24 + v;
            vec3 worldPos = blockPos + cubeVertices[v];

            gl_MeshVerticesEXT[vertexIdx].gl_Position = ubo.proj * ubo.view * ubo.model * vec4(worldPos, 1.0);

            uint faceIdx = v / 4;
            fragColor[vertexIdx] = faceColors[faceIdx];
            fragTexCoord[vertexIdx] = faceTexCoords[v % 4];
        }

        // Generate triangle indices for this block
        for (uint t = 0; t < 12; ++t) {
            uint primIdx = blockIdx * 12 + t;
            uint baseVertex = blockIdx * 24;
            gl_PrimitiveTriangleIndicesEXT[primIdx] = uvec3(
                baseVertex + faceIndices[t * 3 + 0],
                baseVertex + faceIndices[t * 3 + 1],
                baseVertex + faceIndices[t * 3 + 2]
            );
        }
    }
}